---
title: Bloom filter for quick lookups
description: Introduction to Bloom filter
---

## Introduce
In front-end development, a quick look-up problem refers to the need for efficient and fast access to specific information or data within a web application.
This often involves optimizing how users or the system itself retrieves required data from a potentially large dataset or system.
Addressing such challenges is crucial for creating responsive and user-friendly interfaces, particularly in applications requiring real-time or near-instantaneous feedback, such as
**search engines, recommendation systems, and data processing pipelines**.

## Solutions for common quick lookups problem
Assume that we have to check if an usernames is in a list of usernames. 
Let's see some techniques to solve this problem. Each of them both have advantages and disadvantages.

### 1. **Arrays/ Lists**

An array is a simple data structure but requires O(n) time for lookups unless preprocessed into a sorted or indexed format.
```javascript
  const array = [{ name: "Alice", age: 25 }, { name: "Bob", age: 30 }];

  function arrayLookup(name) {
    return array.find(item => item.name === name) || `No record found for ${name}`;
  }

  console.log(arrayLookup("Alice")); // { name: 'Alice', age: 25 }
  console.log(arrayLookup("Charlie")); // No record found for Charlie

```
**Complexity Analysis**:
* Time Complexity:
  - Worst Case: O(n), where n is the length of the array.
  - Best case: O(1) when matching with the first item.

* Space Complexity: O(1) 

### 2. **Hash maps/ Objects**

We store all usernames in a hash set. Hash Map is great for direct key-value lookups with O(1) average time complexity.
```javascript
  const hashMap = new Map();
  hashMap.set("Alice", { age: 25 });
  hashMap.set("Bob", { age: 30 });

  console.log(hashMap.has("Alice"));
  console.log(hashMap.get("Alice")); 
  console.log(hashMap.has("Charlie")); 
```
**Complexity Analysis**:
* Time Complexity:
  - Lookup: O(1) on average for both Map and plain objects
  - Initialization: O(n) for populating the map or object with n items.

* Space Complexity:
  -  O(n) for storing n items in the map or object.

### 3. **Tries/ Prefix Trees**

A Trie (also called a Prefix Tree) is a tree-like data structure that is used for storing and retrieving keys efficiently.
```javascript
  class TrieNode {
    constructor() {
      this.children = {}; // Stores child nodes
      this.isEndOfWord = false; // Marks the end of a word
    }
  }

  class Trie {
    constructor() {
      this.root = new TrieNode(); // Root node
    }

    // Insert a word into the Trie
    insert(word) {
      let currentNode = this.root;
      for (const char of word) {
        if (!currentNode.children[char]) {
          currentNode.children[char] = new TrieNode();
        }
        currentNode = currentNode.children[char];
      }
      currentNode.isEndOfWord = true;
    }

    // Search for a word in the Trie
    search(word) {
      let currentNode = this.root;
      for (const char of word) {
        if (!currentNode.children[char]) {
          return false; // Word does not exist
        }
        currentNode = currentNode.children[char];
      }
      return currentNode.isEndOfWord;
    }

    // Check if any words in the Trie start with a given prefix
    startsWith(prefix) {
      let currentNode = this.root;
      for (const char of prefix) {
        if (!currentNode.children[char]) {
          return false; // Prefix does not exist
        }
        currentNode = currentNode.children[char];
      }
      return true; // Prefix exists
    }

    // Retrieve all words with a given prefix
    getWordsWithPrefix(prefix) {
      const results = [];
      let currentNode = this.root;

      // Traverse to the node representing the last character of the prefix
      for (const char of prefix) {
        if (!currentNode.children[char]) {
          return results; // Prefix does not exist
        }
        currentNode = currentNode.children[char];
      }

      // Perform a DFS to collect all words starting from this node
      const dfs = (node, path) => {
        if (node.isEndOfWord) {
          results.push(path);
        }
        for (const char in node.children) {
          dfs(node.children[char], path + char);
        }
      };

      dfs(currentNode, prefix);
      return results;
    }
  }

  // Example Usage
  const trie = new Trie();
  trie.insert("Alice");
  trie.insert("Charlie");

  console.log(trie.search("Alice")); // true
  console.log(trie.search("Ali")); // false
  console.log(trie.startsWith("A")); // true
  console.log(trie.getWordsWithPrefix("Ch")); // ['Charlie']
```
**Complexity Analysis**:
* Time Complexity:

  **Insertion**
    - Complexity: O(L), where L is the length of the string being inserted.
  
  **Search**
    - Complexity: O(L), where L is length of string being searched

  **Prefix Search (Starts-with)**
    - Complexity: O(L + K), where:
      - L: Length of prefix
      - K: Total number of nodes visited to collect matching results.

  **Deletion**
    - Complexity: O(L), where L is the length of the string being deleted

* Space Complexity:
  - O(A * L * N), where:
    * A: Size of the alphabet (number of possible characters).
    * L: Average length of the strings stored.
    * N: Number of strings in the Trie.

### Large data problem and why bloom filter
We can see that traditional data structures like hash tables or Tries can consume a significant amount of memory, especially for large datasets.
So, this article introduce to you a data structure can work wellin these cases: **Bloom filter**.

## Bloom filter: Abstract
A bloom filter is a probabilistic data structure that is based on hashing. It is extremely space efficient and is typically used to add elements to a set and test if an element is in a set. Though, the elements themselves are not added to a set. Instead a hash of the elements is added to the set.

When testing if an element is in the bloom filter, false positives are possible. It will either say that an element is definitely not in the set or that it is possible the element is in the set.

## Algorithm description
An empty Bloom filter is a bit array of m bits, all set to 0. It is equipped with k different hash functions, which map set elements to one of the m possible array positions.

To add an element, feed it to each of the k hash functions to get k array positions. Set the bits at all these positions to 1.

To test whether an element is in the set, feed it to each of the k hash functions to get k array positions. If any of the bits at these positions is 0, the element is definitely not in the set; if it were, then all the bits would have been set to 1 when it was inserted. If all are 1, then either the element is in the set, or the bits have by chance been set to 1 during the insertion of other elements, resulting in a false positive.
## Probability of false positives
The probability of false positives is a crucial aspect of Bloom filters. It's influenced by the size of the bit array (m), the number of hash functions (k), and the number of elements inserted (n).

The probability of a false positive (P) can be approximated by the following formula:

**P ≈ (1 - e^(-kn/m))^k**

where:

*   **P** is the probability of a false positive
*   **m** is the number of bits in the array
*   **n** is the number of elements inserted
*   **k** is the number of hash functions
*   **e** is the base of the natural logarithm (approximately 2.718)

**Key takeaways:**

*   As **m** (array size) increases, **P** (false positive rate) decreases.
*   As **n** (number of elements) increases, **P** (false positive rate) increases.
*   There's an optimal value for **k** (number of hash functions) that minimizes **P** for a given **m** and **n**. This optimal **k** can be approximated as:

    **k ≈ (m/n) * ln(2)**

In practice, you often choose a desired false positive rate and then calculate the required bit array size and the number of hash functions accordingly.

## Time and space complexity

A bloom filter is extremely efficient in both time and space usage.

**Time Complexity:**

*   **Insertion:** Adding an element requires computing k hash values and setting k bits. This takes **O(k)** time, which is constant for a fixed number of hash functions.
*   **Membership Test:** Checking for an element also requires computing k hash values and checking k bits, resulting in **O(k)** time complexity, again constant.

**Space Complexity:**

*   Bloom filters use a fixed-size bit array of m bits. Thus, the space complexity is **O(m)**. However, **m** is typically much smaller than the space required to store all elements explicitly, making it very space-efficient.

**Comparison with related algorithms:**

| Algorithm      | Insertion Time | Membership Test Time | Space Complexity | False Positives | False Negatives |
| -------------- | -------------- | -------------------- | ---------------- | --------------- | --------------- |
| Bloom Filter   | O(k)           | O(k)                 | O(m)             | Possible        | Not possible    |
| Hash Table    | O(1) average   | O(1) average         | O(n)             | Not applicable  | Not applicable  |
| Set (e.g., HashSet) | O(1) average   | O(1) average         | O(n)             | Not applicable  | Not applicable  |
| Linear Search | O(1)           | O(n)                 | O(n)             | Not applicable  | Not applicable  |

**Key observations:**

*   Bloom filters offer constant time insertion and membership testing, similar to hash tables but with significantly lower space usage.
*   Unlike hash tables and sets, Bloom filters trade accuracy for space efficiency, accepting a small probability of false positives.
*   Compared to linear search, Bloom filters are vastly faster for membership tests.
 
## Example 
Below is example code to implement bloom filter:
```javascript
class BloomFilter {
  /**
   * Creates a new Bloom filter.
   * @param {number} expectedItems - The expected number of items to be added to the filter.
   * @param {number} falsePositiveRate - The desired false positive rate (e.g., 0.01 for 1%).
   */
  constructor(expectedItems, falsePositiveRate) {
    this.expectedItems = expectedItems;
    this.falsePositiveRate = falsePositiveRate;

    // Calculate the size of the bit array (m)
    this.size = this.getSize(expectedItems, falsePositiveRate);

    // Calculate the optimal number of hash functions (k)
    this.hashCount = this.getHashCount(this.size, expectedItems);

    // Initialize the bit array with all bits set to 0
    this.bitArray = new Array(this.size).fill(0);
  }

  /**
   * Calculates the size of the bit array (m) based on the expected number of items and the desired false positive rate.
   * @param {number} n - The expected number of items.
   * @param {number} p - The desired false positive rate.
   * @returns {number} The size of the bit array.
   */
  getSize(n, p) {
    const m = -(n * Math.log(p)) / (Math.log(2) ** 2);
    return Math.ceil(m); // Round up to the nearest integer
  }

  /**
   * Calculates the optimal number of hash functions (k) based on the size of the bit array and the expected number of items.
   * @param {number} m - The size of the bit array.
   * @param {number} n - The expected number of items.
   * @returns {number} The optimal number of hash functions.
   */
  getHashCount(m, n) {
    const k = (m / n) * Math.log(2);
    return Math.ceil(k); // Round up to the nearest integer
  }

  /**
   * Adds an item to the Bloom filter.
   * @param {string} item - The item to add.
   */
  add(item) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.murmurhash3_32_gc(item, i) % this.size; // Use MurmurHash3 with different seeds
      this.bitArray[hash] = 1;
    }
  }

  /**
   * Checks if an item is possibly in the Bloom filter.
   * @param {string} item - The item to check.
   * @returns {boolean} True if the item is probably in the set, false if it's definitely not.
   */
  check(item) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.murmurhash3_32_gc(item, i) % this.size;
      if (this.bitArray[hash] === 0) {
        return false; // Definitely not in the set
      }
    }
    return true; // Probably in the set
  }

  /**
   * A basic implementation of MurmurHash3 for 32-bit numbers (for demonstration purposes). 
   * You might want to use a more robust library in a production environment.
   * Source: https://github.com/garycourt/murmurhash-js
   * @param {string} key - The input string to hash.
   * @param {number} seed - The seed for the hash function.
   * @returns {number} The 32-bit hash value.
   */
  murmurhash3_32_gc(key, seed) {
    var remainder, bytes, h1, h1b, c1, c2, k1, i;

    remainder = key.length & 3; // key.length % 4
    bytes = key.length - remainder;
    h1 = seed;
    c1 = 0xcc9e2d51;
    c2 = 0x1b873593;
    i = 0;

    while (i < bytes) {
        k1 =
          ((key.charCodeAt(i) & 0xff)) |
          ((key.charCodeAt(++i) & 0xff) << 8) |
          ((key.charCodeAt(++i) & 0xff) << 16) |
          ((key.charCodeAt(++i) & 0xff) << 24);
      ++i;

      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

      h1 ^= k1;
          h1 = (h1 << 13) | (h1 >>> 19);
      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }

    k1 = 0;

    switch (remainder) {
      case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
      case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
      case 1: k1 ^= (key.charCodeAt(i) & 0xff);

      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= k1;
    }

    h1 ^= key.length;

    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 16;

    return h1 >>> 0;
  }
}

// Example Usage:
const bloomFilter = new BloomFilter(1000, 0.01); // Expected 1000 items, 1% false positive rate

// Add some items
bloomFilter.add("apple");
bloomFilter.add("banana");
bloomFilter.add("orange");

// Check for membership
console.log(bloomFilter.check("apple"));   // true (Probably)
console.log(bloomFilter.check("grape"));   // false (Definitely)
console.log(bloomFilter.check("banana"));  // true (Probably)
console.log(bloomFilter.check("kiwi"));    // false (Definitely)
```

## Application of bloom filter in real life
Bloom filters find applications in various domains where space efficiency and fast membership tests are crucial: Web Caching, Database Systems, Recommender Systems,...

## Conclusion
They are especially suited for systems where memory is limited, and some uncertainty is tolerable. 
However, for applications needing exact results or requiring deletions, other structures like Tries or hash tables may be more appropriate.

## Reference
- [Bloom filter introduce and python implementation](https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/) - GeeksforGeeks
- [Bloom filter](https://brilliant.org/wiki/bloom-filter/) - Brilliant