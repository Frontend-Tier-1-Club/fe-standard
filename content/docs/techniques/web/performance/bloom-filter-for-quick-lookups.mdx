---
title: Bloom filter for quick lookups
description: Introduction to Bloom filter
---

When dealing with massive datasets of unique items (like URLs, usernames, etc.), storing them directly in traditional data structures (hash tables, sets) can consume a vast amount of memory. This becomes especially problematic when storage is expensive or limited (e.g., in-database indexes, caches).
In the other hand, if we need to frequently check whether an item belongs to a large set, using linear search or even more optimized data structures like hash tables can still result in significant latency, especially as the dataset grows.

Bloom filters provide an elegant solution to these problems by offering a space-efficient and fast way to perform membership tests, albeit with a trade-off (the possibility of false positives).

## Abstract
A bloom filter is a probabilistic data structure that is based on hashing. It is extremely space efficient and is typically used to add elements to a set and test if an element is in a set. Though, the elements themselves are not added to a set. Instead a hash of the elements is added to the set.

When testing if an element is in the bloom filter, false positives are possible. It will either say that an element is definitely not in the set or that it is possible the element is in the set.

## Algorithm description
An empty Bloom filter is a bit array of m bits, all set to 0. It is equipped with k different hash functions, which map set elements to one of the m possible array positions.

To add an element, feed it to each of the k hash functions to get k array positions. Set the bits at all these positions to 1.

To test whether an element is in the set, feed it to each of the k hash functions to get k array positions. If any of the bits at these positions is 0, the element is definitely not in the set; if it were, then all the bits would have been set to 1 when it was inserted. If all are 1, then either the element is in the set, or the bits have by chance been set to 1 during the insertion of other elements, resulting in a false positive.
## Probability of false positives
The probability of false positives is a crucial aspect of Bloom filters. It's influenced by the size of the bit array (m), the number of hash functions (k), and the number of elements inserted (n).

The probability of a false positive (P) can be approximated by the following formula:

**P ≈ (1 - e^(-kn/m))^k**

where:

*   **P** is the probability of a false positive
*   **m** is the number of bits in the array
*   **n** is the number of elements inserted
*   **k** is the number of hash functions
*   **e** is the base of the natural logarithm (approximately 2.718)

**Key takeaways:**

*   As **m** (array size) increases, **P** (false positive rate) decreases.
*   As **n** (number of elements) increases, **P** (false positive rate) increases.
*   There's an optimal value for **k** (number of hash functions) that minimizes **P** for a given **m** and **n**. This optimal **k** can be approximated as:

    **k ≈ (m/n) * ln(2)**

In practice, you often choose a desired false positive rate and then calculate the required bit array size and the number of hash functions accordingly.

## Time and space complexity

A bloom filter is extremely efficient in both time and space usage.

**Time Complexity:**

*   **Insertion:** Adding an element requires computing k hash values and setting k bits. This takes **O(k)** time, which is constant for a fixed number of hash functions.
*   **Membership Test:** Checking for an element also requires computing k hash values and checking k bits, resulting in **O(k)** time complexity, again constant.

**Space Complexity:**

*   Bloom filters use a fixed-size bit array of m bits. Thus, the space complexity is **O(m)**. However, **m** is typically much smaller than the space required to store all elements explicitly, making it very space-efficient.

**Comparison with related algorithms:**

| Algorithm      | Insertion Time | Membership Test Time | Space Complexity | False Positives | False Negatives |
| -------------- | -------------- | -------------------- | ---------------- | --------------- | --------------- |
| Bloom Filter   | O(k)           | O(k)                 | O(m)             | Possible        | Not possible    |
| Hash Table    | O(1) average   | O(1) average         | O(n)             | Not applicable  | Not applicable  |
| Set (e.g., HashSet) | O(1) average   | O(1) average         | O(n)             | Not applicable  | Not applicable  |
| Linear Search | O(1)           | O(n)                 | O(n)             | Not applicable  | Not applicable  |

**Key observations:**

*   Bloom filters offer constant time insertion and membership testing, similar to hash tables but with significantly lower space usage.
*   Unlike hash tables and sets, Bloom filters trade accuracy for space efficiency, accepting a small probability of false positives.
*   Compared to linear search, Bloom filters are vastly faster for membership tests.
 
## Example 
Below is example code to implement bloom filter:
```javascript
class BloomFilter {
  /**
   * Creates a new Bloom filter.
   * @param {number} expectedItems - The expected number of items to be added to the filter.
   * @param {number} falsePositiveRate - The desired false positive rate (e.g., 0.01 for 1%).
   */
  constructor(expectedItems, falsePositiveRate) {
    this.expectedItems = expectedItems;
    this.falsePositiveRate = falsePositiveRate;

    // Calculate the size of the bit array (m)
    this.size = this.getSize(expectedItems, falsePositiveRate);

    // Calculate the optimal number of hash functions (k)
    this.hashCount = this.getHashCount(this.size, expectedItems);

    // Initialize the bit array with all bits set to 0
    this.bitArray = new Array(this.size).fill(0);
  }

  /**
   * Calculates the size of the bit array (m) based on the expected number of items and the desired false positive rate.
   * @param {number} n - The expected number of items.
   * @param {number} p - The desired false positive rate.
   * @returns {number} The size of the bit array.
   */
  getSize(n, p) {
    const m = -(n * Math.log(p)) / (Math.log(2) ** 2);
    return Math.ceil(m); // Round up to the nearest integer
  }

  /**
   * Calculates the optimal number of hash functions (k) based on the size of the bit array and the expected number of items.
   * @param {number} m - The size of the bit array.
   * @param {number} n - The expected number of items.
   * @returns {number} The optimal number of hash functions.
   */
  getHashCount(m, n) {
    const k = (m / n) * Math.log(2);
    return Math.ceil(k); // Round up to the nearest integer
  }

  /**
   * Adds an item to the Bloom filter.
   * @param {string} item - The item to add.
   */
  add(item) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.murmurhash3_32_gc(item, i) % this.size; // Use MurmurHash3 with different seeds
      this.bitArray[hash] = 1;
    }
  }

  /**
   * Checks if an item is possibly in the Bloom filter.
   * @param {string} item - The item to check.
   * @returns {boolean} True if the item is probably in the set, false if it's definitely not.
   */
  check(item) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.murmurhash3_32_gc(item, i) % this.size;
      if (this.bitArray[hash] === 0) {
        return false; // Definitely not in the set
      }
    }
    return true; // Probably in the set
  }

  /**
   * A basic implementation of MurmurHash3 for 32-bit numbers (for demonstration purposes). 
   * You might want to use a more robust library in a production environment.
   * Source: https://github.com/garycourt/murmurhash-js
   * @param {string} key - The input string to hash.
   * @param {number} seed - The seed for the hash function.
   * @returns {number} The 32-bit hash value.
   */
  murmurhash3_32_gc(key, seed) {
    var remainder, bytes, h1, h1b, c1, c2, k1, i;

    remainder = key.length & 3; // key.length % 4
    bytes = key.length - remainder;
    h1 = seed;
    c1 = 0xcc9e2d51;
    c2 = 0x1b873593;
    i = 0;

    while (i < bytes) {
        k1 =
          ((key.charCodeAt(i) & 0xff)) |
          ((key.charCodeAt(++i) & 0xff) << 8) |
          ((key.charCodeAt(++i) & 0xff) << 16) |
          ((key.charCodeAt(++i) & 0xff) << 24);
      ++i;

      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

      h1 ^= k1;
          h1 = (h1 << 13) | (h1 >>> 19);
      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }

    k1 = 0;

    switch (remainder) {
      case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
      case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
      case 1: k1 ^= (key.charCodeAt(i) & 0xff);

      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= k1;
    }

    h1 ^= key.length;

    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 16;

    return h1 >>> 0;
  }
}

// Example Usage:
const bloomFilter = new BloomFilter(1000, 0.01); // Expected 1000 items, 1% false positive rate

// Add some items
bloomFilter.add("apple");
bloomFilter.add("banana");
bloomFilter.add("orange");

// Check for membership
console.log(bloomFilter.check("apple"));   // true (Probably)
console.log(bloomFilter.check("grape"));   // false (Definitely)
console.log(bloomFilter.check("banana"));  // true (Probably)
console.log(bloomFilter.check("kiwi"));    // false (Definitely)
```

## Application of bloom filter in real life
Bloom filters find applications in various domains where space efficiency and fast membership tests are crucial: Web Caching, Database Systems, Recommender Systems,...

## Conclusion
Bloom filters are a powerful probabilistic data structure that offers a compelling solution when dealing with large datasets and the need for fast membership tests. They provide excellent space efficiency and constant time operations for insertion and membership checks. The trade-off is the possibility of false positives, but this can be controlled and minimized by adjusting the filter's parameters.

## Reference
- [Bloom filter](https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/) - GeeksforGeeks
- [Bloom filter] (https://brilliant.org/wiki/bloom-filter/) - Brilliant