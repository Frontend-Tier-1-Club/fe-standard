---
title: JSON Web Tokens Security (JWT)
description: Display file structure in your documentation
preview: "JSON Web Tokens Security (JWT)"
---

import Table from "@/shared/components/table"

# JSON Web Tokens (JWT) Security

JSON Web Tokens (JWT) are a widely used standard for securely transmitting information between parties as a JSON object.
This document outlines JWT's security features, potential vulnerabilities, and best practices for secure implementation.

## Why is JWT Token ?

In the early days of web development, developer want to find a way to manage user authentication and sessions in a more efficient and secure manner. Before the widespread use of JWT (JSON Web Tokens), they relied on several older methods to manage authentication and user sessions like cookies and server-side sessions.
But it had their limitations:

### 1. Server-Side Sessions:

<b>What It Was:</b>
The server stored all session data (e.g., user ID, permissions) and associated it with the session
ID.

{" "}

<b>Drawbacks:</b>
<ul>
  <li>
    <b>Scalability:</b> Storing sessions on the server meant more resource consumption as the user
    base grew.
  </li>
  <li>
    <b>Distributed Systems:</b> Sessions needed synchronization between servers in load-balanced
    environments, requiring complex setups (e.g., sticky sessions or centralized session stores like
    Redis).
  </li>
  <li>
    <b>Revocation Complexity:</b> Managing session invalidation for logout or security purposes was
    challenging.
  </li>
</ul>

### 2. Cookies

{" "}

<b>What It Was:</b>
Cookies stored session data on the client side, with the server validating the session ID.

{" "}

<b>Drawbacks:</b>
<ul>
  <li>
    <b>Vulnerable to XSS/CSRF:</b> Cookies could be intercepted or forged if not properly secured.
  </li>
  <li>
    <b>Limited Storage:</b> Cookies had a 4KB size limit, restricting what could be stored.
  </li>
</ul>

### 3. HTTP Basic Authentication

{" "}

<b>What It Was:</b>
User credentials (username and password) were sent with every request in the Authorization header.

{" "}

<b>Drawbacks:</b>
<ul>
  <li>
    <b>Insecure:</b> Repeatedly transmitting credentials increased the risk of interception, even
    with HTTPS.
  </li>
  <li>
    <b>User Experience:</b> Required constant re-authentication or browser pop-ups for credential
    input.
  </li>
  <li>
    <b>Sessionless:</b> No support for "remember me" or session persistence.
  </li>
</ul>

### 4. JWT Is Preferred Over Older Methods

JWTs addressed many of the issues with previous approaches:

<ul>
  <li>
    <b>Statelessness:</b> Tokens are self-contained; no server-side storage is required.
  </li>
  <li>
    <b>Scalability:</b> Simplifies distributed systems since the token itself carries all necessary
    data.
  </li>
  <li>
    <b>Interoperability:</b> Standardized format (JSON) makes it easy to integrate across systems
    and platforms.
  </li>
  <li>
    <b>Security:</b> When used with best practices (e.g., signing, encryption), JWTs provide robust
    authentication and authorization.
  </li>
</ul>

## What is a JWT Token ?

JSON Web Tokens (JWTs) are a compact and self-contained method for transmitting information between parties. A JWT consists of three parts: a header, a payload, and a signature. The header and payload are Base64Url encoded JSON strings, and the signature is a cryptographic hash of the header, payload, and a secret key.

The header contains metadata about the JWT, such as the algorithm used to sign the token. The
payload contains claims, which are statements about an entity and additional data. Claims can be
used to represent user information, permissions, or other metadata. The signature is used to verify
that the JWT is valid and has not been tampered with.

## Structure of a JWT

A JWT is divided into three parts, separated by dots (`.`):

1. **Header**: Contains metadata, such as the type of token and the signing algorithm (e.g., `HS256` or `RS256`).
2. **Payload**: Contains claims, which are statements about an entity (typically the user) and additional data.
3. **Signature**: Ensures the integrity of the token by allowing verification of its authenticity.

Example:

```text
<base64UrlEncode(header)>.<base64UrlEncode(payload)>.<signature>
```

---

### 1. Header

The header contains metadata about the token, including the type of token and the signing algorithm used. It is a JSON object encoded in Base64Url format. This metadata is crucial for both the sender and the recipient to understand how to process the token. For example:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- **`alg`**: Specifies the algorithm used to sign the token. Common algorithms include:

  - `HS256` (HMAC using SHA-256): Symmetric key algorithm. Both parties share a secret key for signing and verification. Easy to implement but requires secure key management.
  - `RS256` (RSA signature with SHA-256): Asymmetric key algorithm using a private key for signing and a public key for verification. Ideal for distributed systems as only the private key must remain secure.
  - `ES256` (ECDSA using P-256 and SHA-256): Asymmetric key algorithm based on elliptic curves. Offers similar security to RSA but with smaller key sizes and faster performance.
  - `PS256` (RSA-PSS using SHA-256): An advanced variant of RSA with a probabilistic signature scheme, providing stronger cryptographic assurances against certain types of attacks.
  - `EdDSA` (Edwards-curve Digital Signature Algorithm): A highly secure and performant algorithm, often used with Ed25519.

- **`typ`**: Indicates the type of token. Usually set to `JWT` to denote a JSON Web Token.

The `alg` and `typ` fields in the header provide critical information for validating the tokenâ€™s signature and ensuring proper cryptographic handling. Misconfiguration or unsupported algorithms can introduce vulnerabilities, so these fields must be validated rigorously.

### 2. Payload

The payload contains the claims, which are statements about the entity (user) and additional data. Example:

```json
{
  "sub": "1234567890",
  "email": "kevin.tran@techvify.com.vn",
  "name": "Kevin Tran",
  "role": "ADMIN",
  "iat": 1516239022,
  "exp": 1516245022
}
```

- **Registered Claims**: Predefined claims that provide useful, standardized metadata:

  <Table
    headers={["Atribute", "Description"]}
    data={[
      { Atribute: "iss (Issuer)", Description: "Identifies the entity that issued the token." },
      { Atribute: "sub (Subject)", Description: "Identifies the principal subject of the token." },
      {
        Atribute: "aud (Audience)",
        Description: "Identifies the recipients that the token is intended for."
      },
      { Atribute: "exp (Expiration Time)", Description: "Specifies when the token will expire." },
      {
        Atribute: "nbf (Not Before)",
        Description: "Specifies the time before which the token must not be accepted."
      },
      {
        Atribute: "iat (Issued At)",
        Description: "Identifies the time at which the token was issued."
      },
      {
        Atribute: "jti (JWT ID)",
        Description: "A unique identifier for the token, useful for preventing replay attacks."
      }
    ]}
  />

- **Custom Claims**: Application-specific data. For example, `role` or `permissions`. Avoid including sensitive information here as the payload is not encrypted.

### 3. Signature

The signature is created by encoding the header and payload, then signing it using a secret key or a private key, depending on the algorithm. The signature ensures the token's integrity and authenticity. For example:

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

- **Symmetric Algorithms (e.g., HS256)**: Use the same key for signing and verification. Both the sender and receiver must securely share the key.
- **Asymmetric Algorithms (e.g., RS256, ES256)**: Use a private key for signing and a public key for verification. Only the issuer needs to keep the private key secure.

## How to Work With JWT ?

The output is three Base64-URL strings separated by dots that can be easily passed in HTML and HTTP environments, while being more compact when compared to XML-based standards such as SAML.

<img
  className="rounder-md"
  src="/images/javascript/security/sample_token_string.png"
  alt="token-string"
/>

<img className="rounder-md" src="/images/javascript/security/jwt_work_flow.avif" alt="flow_img" />

## Real-world applications of JSON Web Tokens

In the modern web, you will often have several parties communicating with each other. Certain features will naturally be restricted and require some sort of authorization mechanism.

### Stateless Authentication for Web and Mobile Applications

1. Scenario:

- An e-commerce platform has a web app and a mobile app.

- Users log in to their accounts to manage orders, browse products, and make purchases.

2. Implementation:

Login Flow:

- The user logs in via the web or mobile app.

- The authentication server validates the credentials and issues a JWT containing user claims (e.g., user ID, roles, and permissions).

Client-Side Storage:

- Web App: Stores the JWT in an HTTP-only cookie or localStorage.

- Mobile App: Stores the JWT securely using libraries like SecureStorage or Keychain.

Subsequent Requests:

- The client app includes the JWT in the Authorization header (Bearer **token**).

- The server verifies the token on every request by checking the signature and expiration date.

- If valid, the server processes the request without querying a session store.

Example:

- Amazon or Flipkart mobile and web applications use JWTs to authenticate user actions like adding items to the cart or checking order history.

## Challenges and Limitations of JWT

While JWTs offer many benefits, they also come with challenges and limitations that developers must consider:

#### Token Size

JWTs are self-contained tokens that carry all necessary information for authentication and authorization within their structure. Unlike traditional session IDs, which are typically small strings, JWTs consist of three distinct parts

#### Revocation Complexity

JWTs are stateless, meaning they contain all the information needed for authentication within the token itself and do not rely on server-side session storage. Once issued, a JWT is valid until it expires, unless specific measures are taken to revoke it.

#### Expiration and Rotation

Properly managing token lifecycles is critical.

#### Security Risks

Poor implementation can lead to vulnerabilities (e.g., improper validation, weak secret keys).

#### Compatibility

May not be the best fit for every system (e.g., legacy systems relying on server-side sessions).

## JWT and Session ?

- Compare JWT and Session (with table)

## Conclusion

JWTs are a powerful tool for authentication and secure data exchange. However, they must be implemented with care to avoid common pitfalls. Following best practices ensures that your application remains secure while leveraging the benefits of JWTs.
