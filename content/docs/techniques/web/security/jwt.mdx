---
title: JSON Web Tokens Security (JWT)
description: Display file structure in your documentation
preview: "JSON Web Tokens Security (JWT)"
---

import Table from "@/shared/components/table"

export const data = [
  { Atribute: "iss (Issuer)", Description: "Identifies the entity that issued the token." },
  { Atribute: "sub (Subject)", Description: "Identifies the principal subject of the token." },
  {
    Atribute: "aud (Audience)",
    Description: "Identifies the recipients that the token is intended for."
  },
  { Atribute: "exp (Expiration Time)", Description: "Specifies when the token will expire." },
  {
    Atribute: "nbf (Not Before)",
    Description: "Specifies the time before which the token must not be accepted."
  },
  {
    Atribute: "iat (Issued At)",
    Description: "Identifies the time at which the token was issued."
  },
  {
    Atribute: "jti (JWT ID)",
    Description: "A unique identifier for the token, useful for preventing replay attacks."
  }
]

# JSON Web Tokens (JWT) Security

JSON Web Tokens (JWT) are a widely used standard for securely transmitting information between parties as a JSON object.
This document outlines JWT's security features, potential vulnerabilities, and best practices for secure implementation.

## Why is JWT Token ?

In the early days of web development, developer want to find a way to manage user authentication and sessions in a more efficient and secure manner. Before the widespread use of JWT (JSON Web Tokens), they relied on several older methods to manage authentication and user sessions like cookies and server-side sessions.
But it had their limitations:

### 1. Server-Side Sessions Problems ?

The server stored all session data (e.g., user ID, permissions) and associated it with the session
ID.

**Drawbacks:**

- **Scalability:** Storing sessions on the server meant more resource consumption as the user
  base grew.

- **Distributed Systems:** Sessions needed synchronization between servers in load-balanced
  environments, requiring complex setups (e.g., sticky sessions or centralized session stores like
  Redis).

- **Revocation Complexity:** Managing session invalidation for logout or security purposes was
  challenging.

### 2. Cookies Problems ?

Cookies stored session data on the client side, with the server validating the session ID.

**Drawbacks:**-**Vulnerable to XSS/CSRF:** Cookies could be intercepted or forged if not
properly secured. -**Limited Storage:** Cookies had a 4KB size limit, restricting what could be
stored.

### 3. HTTP Basic Authentication Problems ?

User credentials (username and password) were sent with every request in the Authorization header.

**Drawbacks:**

- **Insecure:** Repeatedly transmitting credentials increased the risk of interception, even with
  HTTPS.

- **User Experience:** Required constant re-authentication or browser pop-ups for credential
  input.

- **Sessionless:** No support for "remember me" or session persistence.

### 4. JWT Is Preferred Over Older Methods

JWTs addressed many of the issues with previous approaches:

- **Statelessness:** Tokens are self-contained; no server-side storage is required.

- **Scalability:** Simplifies distributed systems since the token itself carries all necessary
  data.

- **Interoperability:** Standardized format (JSON) makes it easy to integrate across systems and
  platforms.

- **Security:** When used with best practices (e.g., signing, encryption), JWTs provide robust
  authentication and authorization.

## What is a JWT Token ?

JSON Web Tokens (JWTs) are a compact and self-contained method for transmitting information between parties. A JWT consists of three parts: a header, a payload, and a signature. The header and payload are Base64Url encoded JSON strings, and the signature is a cryptographic hash of the header, payload, and a secret key.

The header contains metadata about the JWT, such as the algorithm used to sign the token. The
payload contains claims, which are statements about an entity and additional data. Claims can be
used to represent user information, permissions, or other metadata. The signature is used to verify
that the JWT is valid and has not been tampered with.

### Structure of a JWT

A JWT is divided into three parts, separated by dots (`.`):

1. **Header**: Contains metadata, such as the type of token and the signing algorithm (e.g., `HS256` or `RS256`).
2. **Payload**: Contains claims, which are statements about an entity (typically the user) and additional data.
3. **Signature**: Ensures the integrity of the token by allowing verification of its authenticity.

Example:

```text
<base64UrlEncode(header)>.<base64UrlEncode(payload)>.<signature>
```

---

#### 1. Header

The header contains metadata about the token, including the type of token and the signing algorithm used. It is a JSON object encoded in Base64Url format. This metadata is crucial for both the sender and the recipient to understand how to process the token. For example:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- **`alg`**: Specifies the algorithm used to sign the token. Common algorithms include:

  - `HS256` (HMAC using SHA-256): Symmetric key algorithm. Both parties share a secret key for signing and verification. Easy to implement but requires secure key management.
  - `RS256` (RSA signature with SHA-256): Asymmetric key algorithm using a private key for signing and a public key for verification. Ideal for distributed systems as only the private key must remain secure.
  - `ES256` (ECDSA using P-256 and SHA-256): Asymmetric key algorithm based on elliptic curves. Offers similar security to RSA but with smaller key sizes and faster performance.
  - `PS256` (RSA-PSS using SHA-256): An advanced variant of RSA with a probabilistic signature scheme, providing stronger cryptographic assurances against certain types of attacks.
  - `EdDSA` (Edwards-curve Digital Signature Algorithm): A highly secure and performant algorithm, often used with Ed25519.

- **`typ`**: Indicates the type of token. Usually set to `JWT` to denote a JSON Web Token.

The `alg` and `typ` fields in the header provide critical information for validating the token’s signature and ensuring proper cryptographic handling. Misconfiguration or unsupported algorithms can introduce vulnerabilities, so these fields must be validated rigorously.

#### 2. Payload

The payload contains the claims, which are statements about the entity (user) and additional data. Example:

```json
{
  "sub": "1234567890",
  "email": "kevin.tran@techvify.com.vn",
  "name": "Kevin Tran",
  "role": "ADMIN",
  "iat": 1516239022,
  "exp": 1516245022
}
```

- **Registered Claims**: Predefined claims that provide useful, standardized metadata:

  <Table headers={["Atribute", "Description"]} data={data} />

- **Custom Claims**: Application-specific data. For example, `role` or `permissions`. Avoid including sensitive information here as the payload is not encrypted.

#### 3. Signature

The signature is created by encoding the header and payload, then signing it using a secret key or a private key, depending on the algorithm. The signature ensures the token's integrity and authenticity. For example:

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

- **Symmetric Algorithms (e.g., HS256)**: Use the same key for signing and verification. Both the sender and receiver must securely share the key.
- **Asymmetric Algorithms (e.g., RS256, ES256)**: Use a private key for signing and a public key for verification. Only the issuer needs to keep the private key secure.

The output is three Base64-URL strings separated by dots that can be easily passed in HTML and HTTP environments, while being more compact when compared to XML-based standards such as SAML.

<img
  className="rounder-md"
  src="/images/javascript/security/sample_token_string.png"
  alt="token-string"
/>

## How to Work With JWT ?

How are signed tokens used in authentication? Here’s a simplified outline of the process:

1. A user signs into their account on an authentication server
2. The authentication server returns a signed token with their account information or an ID (or both)
3. The signed token is stored in the browser’s localStorage or sessionStorage or anywhere the website prefers to store it
4. The signed token is retrieved and used anytime a part of the website needs authenticated access

Here’s a visual representation of the process:

<img className="rounder-md" src="/images/javascript/security/jwt_work_flow.avif" alt="flow_img" />

## The problem JWT aims to solve

JSON Web Tokens (JWTs) address several business pain points, particularly in modern application architectures and security models.

### Scalability in Authentication

A growing e-commerce platform hosts millions of users who frequently log in,
browse products, and make purchases. The platform initially implemented session-based
authentication, where user sessions are stored on the server. However, as the platform scaled, this
approach began to show significant limitations, even though it can become a bottleneck as the user
base grows

**Solution with JWT:** JWTs are stateless and do not require server-side storage. The token
itself carries all the necessary data for authentication, allowing seamless scaling across
distributed systems.

### Cost Management

A growing SaaS company offers a multi-tenant platform used by thousands of
businesses. As their user base expands, they face escalating costs in managing authentication and
session storage due to traditional session-based authentication.

**Solution with JWT:** By removing the dependency on session storage, JWTs reduce infrastructure
costs and simplify system architecture.

### Security Concerns

Traditional authentication methods often expose sensitive session data to risks
like session hijacking. However, many companies especially the fintech companies manage an online
banking platform where users perform sensitive transactions like fund transfers and account
management. The platform initially uses traditional session-based authentication. However, the
company encounters significant security risks

**Solution with JWT:** Tokens are signed and optionally encrypted, ensuring integrity and
confidentiality. They can include short expiration times and support mechanisms like refresh tokens
to minimize risks.

### Developer Productivity

A logistics company operates a digital platform where users access services via
web, mobile apps (iOS and Android), and APIs for third-party integrations. They face challenges with
consistent authentication across all platforms due to differing technologies and session management
requirements.

**Solution with JWT:** JWT solves cross-platform compatibility pain points by offering a
standardized, portable, and secure authentication method that works seamlessly across web, mobile,
and API environments.

### Customer Experience

A subscription-based streaming service offers users access to content across
multiple devices, including web, mobile, smart TVs, and gaming consoles. Customers expect quick and
seamless authentication, but traditional methods create friction, leading to frustration and
drop-offs.

**Solution with JWT:** JWTs can support single sign-on (SSO) and allow users to remain logged in
across multiple devices and services until the token expires.

## Challenges and Limitations of JWT

While JWTs offer many benefits, they also come with challenges and limitations that developers must consider:

### Limited Token Size

JWTs can become significantly larger than traditional session IDs because they contain headers,
payloads, and cryptographic signatures. If you use the JSON Compact Serialized format (most common format),
you have to keep in mind that it should be as short as possible because it is mainly used in a web context. A **4kb** JWT is something that you should avoid.

**Impact:**

- Increases bandwidth usage, especially in systems with frequent requests.

- May impact performance over slow networks (e.g., mobile or IoT).

### Revocation Complexity

Despite the convenience and efficiency offered by JWT tokens, they have a significant limitation
when it comes to handling revoked tokens. Consider a scenario where a user’s access rights are
revoked before the expiration time of their JWT token. In this case, the resource server has no way
of knowing that the token has been revoked. It will continue to accept the token as valid until it
expires, potentially allowing unauthorized access to protected resources.

**Impact:**

- If a JWT is compromised, it remains valid until it expires.

- May impact performance over slow networks (e.g., mobile or IoT).

### Expiration and Rotation

One challenge when using JWTs is handling token rotation and key updates. JWTs have an expiration
time, after which they are considered invalid. When a token needs to be renewed or rotated, it’s
important to ensure a smooth transition without disrupting the user experience. In addition,
periodically updating the signing key helps enhance security and mitigate the impact of a
compromised key.

**Impact:**

- Short-lived tokens enhance security but require refresh tokens, adding complexity to token
  rotation.

- Long-lived tokens increase security risks if they are compromised.

### Security Risk

In the world of web security, JSON Web Tokens (JWTs) play a pivotal in role in managing
authentication and maintaining session information. However, the security of JWTs is only as robust
as the mechanisms and practices employed to handle them.

**Impact:**

- **Token Tampering:** Without proper signature verification, JWTs can be altered by attackers.

- **Algorithm Confusion:** Misconfiguration of signing algorithms (e.g., using "none") can lead
  to vulnerabilities.

- **Sensitive Data Exposure:** Claims stored in the payload can be decoded easily if not
  encrypted, exposing sensitive information.

### Compatibility

JWTs follow a widely accepted standard (RFC 7519), which makes them suitable for modern
applications. However, integrating JWTs into existing systems or across diverse environments can
present compatibility challenges. These issues often arise in legacy systems, heterogeneous
ecosystems, and when dealing with varying standards and protocols.

**Impact:**

- May require additional middleware or libraries to handle JWTs in legacy systems.

- Compatibility issues can arise when integrating JWTs into systems with different encryption
  standards.

## What Happens if Your JSON Web Token is Stolen?

It's really bad if JWTs are stolen, because an attacker has full access to the user’s account in the same way they would if the attacker had instead compromised the user’s username and password.

For instance, if an attacker gets ahold of your JWT, they could start sending requests to the server identifying themselves as you and do things like make service changes,
user account updates, etc. Once an attacker has your JWT it is game over.

**BUT**, there is one thing that makes a stolen JWT slightly less bad than a stolen username and
password: timing. Because JWTs can be configured to automatically expire after a set amount of time
(a minute, an hour, a day, whatever), attackers can only use your JWT to access the service until it
expires.

In theory, that sounds great, right? One of the ways token authentication is said to make authentication more “secure” is via short-lived tokens.
That’s one of the core reasons token-based authentication has really taken off in recent years: you can automatically expire tokens and mitigate the risk of relying on forever-cached “stateless” tokens.

In the security world, after all, relying on cached data to make sensitive decisions like who can log into a service and what they can do is considered a bad thing. Because tokens are stateless and allow for some speed improvements over traditional session authentication, the only way in which they can remain somewhat “secure” is by limiting their lifespan so they don’t cause too much harm when compromised.

The only problem here is that if an attacker was able to steal your token in the first place, they’re likely able to do it once you get a new token as well. The most common ways this happens is by man-in-the-middling (MITM) your connection or getting access to the client or server directly. And unfortunately, in these scenarios, even the shortest-lived JWTs won’t help you at all.

Another interesting thing to consider is that ** in some cases, a stolen JWT can actually be worse than a stolen username and password. **

Let’s pretend, for a moment, that your username and password have been compromised. In this scenario, if the app you’re logging into is protected with multi-factor authentication, an attacker needs to bypass additional identity proofing mechanisms in order to gain access to your account.

While guessing or brute-forcing a username and password is a very realistic scenario, being able to compromise a user’s mutli-factor authentication setup can be quite difficult. Bypassing factors like app-based authorization, SMS verification, face ID, touch ID, etc., is a significantly more challenging than guessing a user’s password.

Because of this, a compromised JWT can actually be a greater security risk than a compromised username and password. Imagine the scenario above where the app a user logs into is protected by multi-factor authentication. Once the user logs in and verifies themselves via multi-factor, they are assigned a JWT to prove who they are. If that JWT is stolen, the attacker no longer needs to bypass MFA directly (like they would have to if they only had the user’s username and password)—they can now directly make requests as the user without additional identity proofing. Quite a big risk.

## What To Do If Your JWT Is Stolen

Here are a number of steps to take if a client’s token has been stolen. These recommendations are not suitable for every type of app, but should provide you with some good ideas to help you recover from this security incident:

I am going to give you sample about how to do when JWT is stolen so you need to setup a basic server with ExpressJs

```js filename = "index.js"
const express = require("express")
const jwt = require("jsonwebtoken")
const bodyParser = require("body-parser")
const { revokeToken, isTokenRevoked } = require("./revokedTokens")
const app = express()
const PORT = 3000
const SECRET_KEY = "techvify_or_smt_secret_password" // Replace with a secure secret key.

app.use(bodyParser.json())

// Endpoint to issue a JWT
app.post("/login", (req, res) => {
  const { username } = req.body

  if (!username) {
    return res.status(400).json({ message: "Username is required" })
  }

  const token = jwt.sign({ username }, SECRET_KEY, { expiresIn: "1h" })
  res.json({ token })
})

// Middleware to verify JWT
const authenticate = async (req, res, next) => {
  const authHeader = req.headers.authorization

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ message: "Unauthorized" })
  }

  const token = authHeader.split(" ")[1]

  // Check if the token is revoked
  const isRevoked = await isTokenRevoked(token)
  if (isRevoked) {
    return res.status(401).json({ message: "Token has been revoked" })
  }

  try {
    req.user = jwt.verify(token, SECRET_KEY)
    next()
  } catch (err) {
    return res.status(401).json({ message: "Invalid or expired token" })
  }
}

// Protected route
app.get("/protected", authenticate, (req, res) => {
  res.json({ message: "Welcome to the protected route", user: req.user })
})

// Start the server
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`)
})
```

- **Revoke compromised tokens immediately.** If you’re using a revocation list on your server
  to invalidate tokens, revoking a token can instantly boot the attacker out of your system until
  they get hold of a new token. While it is a temporary solution, it will make the attacker’s life
  slightly more difficult.

  Example with ExpressJs, if you want to revoke, simply you just create Endpoint to revoke a token

  ```js filename = "index.js"
  // Endpoint to revoke a token
  app.post("/revoke", async (req, res) => {
    const { token } = req.body

    if (!token) {
      return res.status(400).json({ message: "Token is required" })
    }

    await revokeToken(token)
    res.json({ message: "Token revoked successfully" })
  })
  ```

  **Revoke the Token:**

  ```bash
    curl -X POST -H "Content-Type: application/json" -d '{"token":"your_generated_jwt"}' http://localhost:3000/revoke
  ```

  ```json
  {
    "message": "Token revoked successfully"
  }
  ```

- **Force your client to change their password immediately.** In the context of a web or mobile
  app, force your user to reset their password immediately, preferably through some sort of
  multi-factor authentication flow like the ones Okta provides. Forcing a user to change their
  password can potentially keep attackers out of their account in the event that an attacker tries
  to use a compromised token to modify user login credentials. By requiring multi-factor
  authentication, you can have more confidence that the user resetting their credentials is who they
  say they are and not an attacker.

  You have to change different password immediately. I suggest that it have to be a code that had been hash and complex

  ```js
  const SECRET_KEY = "hash_code_or_something_complex"
  ```

- **Inspect the client’s environment.** Was the user’s phone stolen so an attacker has access
  to their pre-authenticated mobile app? Was the client accessing your service from a compromised
  device like a mobile phone or infected computer? Discovering how the attacker got a hold of the
  token is the only way to fully understand what went wrong.

  To inspect the client’s environment in the event of a potential security breach,
  you can implement a logging system that collects metadata about the client's environment when a suspicious activity occurs.

  Here’s how you might approach this in **Express.js** with `geoip-lite` and `useragent`.

  ```bash
    npm install geoip-lite useragent
  ```

```js
// Middleware to log environment details
app.use((req, res, next) => {
  const ip = req.ip || req.headers["x-forwarded-for"] || req.connection.remoteAddress
  const agent = useragent.parse(req.headers["user-agent"])
  const geo = geoip.lookup(ip)

  req.clientMetadata = {
    ip,
    location: geo || "Unknown",
    userAgent: agent.toString()
  }

  next()
})

// Endpoint to simulate login and inspect the environment
app.post("/login", (req, res) => {
  const { username } = req.body
  //... check user exist...
  const user = users.find(u => u.username === username)

  if (!user) {
    return res.status(404).json({ message: "User not found" })
  }

  // Check for suspicious activity
  const { ip, location, userAgent } = req.clientMetadata

  let warnings = []
  if (user.lastKnownIp && user.lastKnownIp !== ip) {
    warnings.push(`Login from a new IP address: ${ip}`)
  }
  if (user.lastKnownLocation && user.lastKnownLocation !== location) {
    warnings.push(`Login from a new location: ${JSON.stringify(location)}`)
  }
  if (user.lastUserAgent && user.lastUserAgent !== userAgent) {
    warnings.push(`Login from a new device: ${userAgent}`)
  }

  // Save new metadata
  user.lastKnownIp = ip
  user.lastKnownLocation = location
  user.lastUserAgent = userAgent

  res.json({
    message: "Login successful",
    metadata: req.clientMetadata,
    warnings: warnings.length > 0 ? warnings : "No suspicious activity detected"
  })
})
```

You can base on the information returned by the api to be able to judge where the hacker is coming from

```json
{
  "message": "Login successful",
  "metadata": {
    "ip": "192.168.1.2",
    "location": {
      "country": "HN",
      "region": "NV",
      "city": "Vietnam"
    },
    "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
  },
  "warnings": [
    "Login from a new IP address: 192.168.1.2",
    "Login from a new location: {\"country\":\"HN\",\"region\":\"NV\",\"city\":\"VietNam\"}",
    "Login from a new device: Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
  ]
}
```

- **Inspect your server-side environment.** Was an attacker able to compromise the token from
  your end? If so, this might involve a lot more work to fix, but the earlier you get started the
  better.

  In ExpressJs, I recommend you `morgan` and `winston` libraries to inspect because It provide a powerful logging and monitoring solution
  that can help you inspect and troubleshoot your server's behavior

  ```bash
    npm install morgan winston
  ```

  ```js
  const morgan = require("morgan") // Request logger
  const winston = require("winston") // Advanced logging

  // Setup logging with Winston
  const logger = winston.createLogger({
    level: "info",
    format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
    transports: [
      new winston.transports.Console(),
      new winston.transports.File({ filename: "server.log" })
    ]
  })

  // Middleware to log suspicious requests
  app.use(
    morgan("combined", {
      stream: {
        write: message => logger.info(message.trim())
      }
    })
  )
  ```

  **Logged Request:**

  ```json
  {
    "level": "info",
    "message": "POST /secure-endpoint 403 - - 4.356 ms",
    "timestamp": "2025-01-21T12:34:56.789Z"
  }
  ```

  **Logged Environment Inspection:**

  ```json
  {
    "level": "info",
    "message": "Server environment inspection triggered",
    "timestamp": "2025-01-21T12:35:56.789Z",
    "memoryUsage": {
      "rss": 25952256,
      "heapTotal": 6062080,
      "heapUsed": 4128320,
      "external": 1050375
    },
    "uptime": 1234.56,
    "nodeVersion": "v18.16.0",
    "environment": "development"
  }
  ```

Once you’ve gone through these steps,
you should hopefully have a better understanding of how the token was compromised and what needs to be done to prevent it from happening in the future.

## Conclusion

JWTs are a powerful tool for authentication and secure data exchange. However, they must be implemented with care to avoid common pitfalls. Following best practices ensures that your application remains secure while leveraging the benefits of JWTs.
